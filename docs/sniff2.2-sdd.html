<html>
<head>
<title>Software Design Document</title>
</head>
<body bgcolor="#99CCCC">
<div align="center"><h1><b>Sniff v2.2</b></h1></div>
<div align="center"><h2><b>Software Design Document</b></h2></div>
<font size="+1">
<div align="right"><b>December 09, 2004</b></div>
<hr>
<h2><b>1. Scope:</h2></b>
<p>This document describes the software design of the network monitoring tool Sniff v2.2. It explains the triple-process architecture built into the software, the module design and the inter-module relations. It also covers the webpage interface, packet dumping and subsequent offline analysis features supported by the software. Kindly go through the <a href="sniff2.2-srs.html">System Requirements</a> and the <a href="sniff2.2-manual.html">User Documentation</a> also.</p>

<br>
<h2><b>2. Overview:</h2></b>
<p>The document consists of four main sections. The first section is about the triple-process architecture and it explains how the three processes involved are made to interact with one other. The second section describes the packet capturing and the layerwise analysis of the packets. The third section describes the user interface (both console and webpage) provided by the software. The fourth section explains the auxiliary functionalities provided with the tool, which include packet dumping and offline packet analysis.</p>

<br>
<h2><b>3. Triple Process Architecture:</h2></b>
<p>The triple-process architecture of the software enables Sniff to spawn three separate processes, which synchronize with one other and accomplish the tasks of packet capturing, packet analysis and analysis summary simultaneously. The motivation behind this architecture is to cope up with the pressing demands of heavily loaded networks when it may become infeasible for one process to perform all the three tasks. The processes communicate with each other through common shared circular memory buffers built upon the IPC (Interprocess Communication) libraries provided with Unix and Linux distributions. The synchronization is achieved using semaphores.</p>

<b>3.1 Shared Memory:</b>
<p>The shared memory is initialized in the main file <i>sniff.c</i> with an appropriate size set at compile time. In Unix IPC, shared memory is accessible by different processes through a common key known to all the participating processes. Apart from the knowledge of the key, the process that creates the memory must provide adequate permissions for the other process to be able to access the buffer. The parent process (invoked initially) spawns a "child" process using the fork utility provided by Unix. Now, both the parent and child processes set up their connections with the shared memory buffer using the common key. The processes keep track of their identity (whether its the child or the parent) with the help of their respective PIDs (process IDs).</p>

<p>The three processes execute separate blocks of code (in files <i>packet_dump.h, packet_analyse.h</i> and <i>packet_summary.h</i>) which carry out their assigned tasks. The parent process dumps all the packets captured (by the packet capture libraries as explained in Section 2) into the shared memory. The packet headers (generated by the network library) are also dumped in an interleaved fashion. As the buffer is circular in nature, the process goes to write at the beginning of the buffer when it reaches the end of the alloted shared memory. The child process performs the packet analysis task. It reads from the shared memory and dispatches packets read for analysis. (Packet analysis is described in the next section.) The size of the packet is stored in the header that preceeds it, using which the required number of bytes are read.</p>

<p>The packet analysing (child) process shares another chunk of memory with the analysis summary (grandchild!) process. This shared memory is used to capture statistics required to be displayed by the analysis summary process. It stores the profile of the packets sent by each of the machines present in the network, which includes the machine address, IP address, protocolwise distribution of the packets generated and timestamps of the packets. The statistics are stored in a linked list (data structure is coded in <i>basket.h</i>) in which each element corresponds to a machine in the network (and is identified by the machine address of the system). When the child process analyses a packet, it updates the appropriate counters stored in the element which represents the system (that generated that packet).</p>

<p>The analysis summary (grandchild) process periodically consolidates the statistics collected in the shared memory (for analysis summary) and displays the summary on the screen. The details of the user interface is explained in the next section.</p>

<b>3.2 Semaphore Synchronization:</b>
<p>Appropriate use of shared memory needs synchronization between the processes and this is achieved by the use of semaphores. The file <i>semaphore.h</i> provides semaphore initialization and semaphore operator functions. The semaphores used are based on the Unix IPC libraries. The semaphore is accessible to both the processes through a common semaphore ID (semID) known to both the processes. The value stored in the semaphore indicates the number unread packets in the shared memory buffer. It is initialized to zero. The semaphore value is incremented after the (packet dumping) parent process successfully dumps a whole packet. The (packet analysing) child process waits on the semaphore untill it has a value greater than zero and decrements it after a whole packet is read out. Thus eventualities of a buffer underflow are averted.</p>

<p>Buffer overflow occurs when either the packet header or the packet itself cannot be written within the bounds of the memory alloted. The (writer) parent process proceeds to the beginning of the circular buffer when either of these situations occurs. The (reader) child process deciphers the broken header (as it knows the size of a complete header) or a broken packet (as it knows the packet size from the preceeding header) and proceeds to the beginning of the buffer to read the next packet.</p>

<p>Thus the three processes spawned interact with one other and perform the their respective tasks.</p>
<br>

<h2><b>4. Network Architecture:</h2></b>
<p>The network architecture of the software comprises of packet capturing and packet analysis engines. One captures all the packets accessible by the network interface while the other analyses the packets captured.</p>

<b>4.1 Packet Capturing:</b>
<p>The packet capturing engine is based on the PCAP (Packet Capture) library provided with Unix and Linux distributions. The appropriate initializations are performed in the main file sniff.c. The tool provides control over the packets that are captured through filters. Filters can be set by the users through a simple <i>config file</i>, which can be (optionally) specified at command line when the tool is invoked. The format to be used in the config files is described in the <a href="sniff2.2-manual.html#config">User Documentation</a>. The users may also specify the number of packets to be analysed by the tool, as described in the <a href="sniff2.2-manual.html#usage">Usage Options</a>.</p>

<b>4.2 Packet Analysis:</b>
<p>The packet analysis engine has a layered architecture corresponding to the architecture of network protocol stacks. When a packet is completely read, it is analysed for the protocol(s) at the lowest machine level. Then, the packet is analysed for the network, transport and application layer protocols through successive recursions. The routines that extract the packet information pertaining to their respective network layers are written protocol-wise. At each layer, the required information is collected (and logged), the protocol used at the higher layer is deciphered and the appropriate (higher layer protocol) routine is called. The files of the form <i>&lt protocol-name &gt.h</i> contain the data structures and functions for the protocols they respectively analyse. The data structures comprise of the packet header structures for the protocols. The functions accomplish the tasks of extraction of the required information and logging the information.</p>
<br>
<h2><b>5. User Interface:</h2></b>
<p>Sniff (ver2.2 onwards) provides two kinds of user interfaces, viz. Console Interface and Webpage Interface.</p>

<b>5.1 Console Interface</b>
<p>The console-based user interface provided by the software is built on the NCURSES library. The user interface is entirely handled by the analysis summary (grandchild) process. It periodically consolidates the statistics collected in the shared memory and refreshes the screen with the latest updated summary. The summary displayed includes current time, total number of packets received, average packet density in the network, machinewise profile of the packets analysed and protocolwise profile of the packets. The machinewise profile includes the machine address, IP address, number of packets generated and protocolwise distribution of the packets for the most active systems in the network. The protocolwise profile includes the protocolwise distribution of all the packets analysed so far. The refresh rate of the screen is set at compile time. A sample <a href="sniff2.2-manual.html#screen">screenshot</a> of the user interface is available.</p>

<b>5.2 Webpage Interface:</b>
<p>The webpage interface provided by the software is based on CGI (Common Gateway Interface) and Perl. The analysis summary process periodically provides the information that needs to be spawned into a webpage. The webpage is spawned by the CGI script <i>iitm_sniff.pl</i>, which displays the information passed by the analysis summary process. The information is passed through a file that is written by the summary process and read by the CGI script. Appropriate file locks are used to avoid race conditions. A sample <a href="iitm_sniff.cgi.html">webpage</a> spawned by the interface CGI script is also provided.</p>
<br>
<h2><b>6. Auxiliary Tools:</h2></b>
<p>The software provides tools for raw-packet dumping and offline analysis of the dumped packets.</p>

<b>6.1 Raw Packet Dumping:</b>
<p>The program <i>sniff_dump.c</i> dumps all the packets raw (without any analysis) into a file. The file path must be passed as a command line arguement. To achieve high performance levels, it is advisible to use a file created on a RAMDISK (file system created on the main memory) partition. Memory access is much faster than hard disk access. The file <i>ramsetup.sh</i> provides a simple shell script to set up a RAMDISK partition.</p>

<b>6.2 Offline Packet Analysis:</b>
<p>The program <i>sniff_open.c</i> reads dumped packets from a dump file (created by sniff_dump) and logs the information extracted offline.</p>
<hr>
<i>Project developed by Kamesh Raghavendra (<a href="mailto: kameshr@gmail.com">kameshr@gmail.com</a>) under the guidance of Prof. R Kalyana Krishnan, Dept. of CSE, IIT Madras</i>
</font>
</body>
</html>
